<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>액티비티 수명주기</title>
  <style type="text/css">
    body {
      width: 80%;
      margin: 2% auto;
    }

    header a {
      font-size: 20px;
    }

    article {
      font-size: 20px;
      font-weight: bold;
    }

    article a {
      font-size: 20px;
      font-weight: bold;
    }

    img {
      display: block;
      margin: 0 auto;
    }

    footer a {
      font-size: 16px;
    }
  </style>
</head>

<body>
  <header>
    <a href="list.html">목록으로</a>
  </header>

  <section>
    <ul>
      <li>
        <article>
          <h2>액티비티의 상태</h2>
          <p>
            안드로이드의 액티비티에는 3가지의 상태를 가지고 있다. 그 상태들에서 잠깐 알아보자.
            <img src="image/activity_lifecycle/activity_lifecycle_01.PNG" alt=""> 위의 그림에 있는 설명은 액티비티 A의 상태를 나타낸 설명이다.
            <ul>
              <li>재개됨(Resumed)</li>
              액티비티가 화면 맨 앞에 있고(맨 위에 있고, 포그라운드에 있고) 사용자의 포커스를 가지고 있는 상태를 말한다. ("실행 중"이라고 말할 때도 있다.)
              <li>일시정지됨(Paused)</li>
              다른 액티비티가 맨 앞에 있고 사용자의 포커스를 가지고 있지만, 현재 액티비티도 여전히 표시되어 있는 상태를 말한다. 위의 그림중 가운데 그림에 해당된다.
              <br>쉽게 말해서 조금이라도 화면에 보이면 그 액티비티는 일시정지 상태라고 할 수 있다.
              <br><br>일시 정지된 액티비티는 완전히 살아 있다. 살아 있다는 말은 Activity 객체가 메모리에 보관되어 있고, 모든 상태 및 멤버 정보를 유지하며, 창 관리자에 붙어있는 상태로 유지되어 있다는 것을 말한다.
              <br>하지만 메모리가 부족한 경우 시스템에 의해 중단될 수 있다. 중단된 말은 Activity 객체가 메모리에서 사라진다는 말이며, 가지고 있던 모든 정보가 날라간다는 뜻을 의미한다.
              <br>때문에 일시 정지 상태가 되면 액티비티의 상태를 따로 저장해 두는 것이 좋다.
              <li>정지됨(Stopped)</li>
              다른 액티비티에 의해 화면에서 완전히 가려진 상태를 말한다.(액티비티가 이제 '백그라운드'에 위치한다.) 하지만 정지 상태의 액티비티 역시 아직 살아있기는 마찬가지이다.(메모리에 보관되어 있음)하지만 일시정지 상태와 다르게 창 관리자에 붙어있지는 않다. 정지 상태의 액티비티 역시 시스템에 의해 메모리에서 중단될 수 있다.
            </ul>
            <br>안드로이드의 액티비티에는 위와 같은 상태가 존재하며 상태의 전화에 따른 수명 주기 콜백 메소드가 존재한다. 이제 그것에 대해서 알아보겠다.
          </p>
        </article>
      </li>

      <li>
        <article>
          <h2>수명 주기 콜백 메소드</h2>
          <p>
            먼저 액티비티의 수명주기에 대해서 알아보자. Activity의 객체가 생성되어 메모리에 올라가고 메모리에서 지워질 때까지를 액티비티의 일생이라고 할 수 있겠다. 구글에서는 이 액티비티의 수명을 3종류로 나누었는데 그것에 대해서도 추후에 알아보도록 하겠다.
            <br><br>액티비티의 콜백 메소드는 모두 후크로서, 액티비티 상태가 변경될 때 적절한 작업을 하기 위해 이를 재정의 할 수 있다.
            <br>대표적인 수명주기 메소드는 아래와 같은 것이 있다.
            <img src="image/activity_lifecycle/activity_lifecycle_04.PNG" alt=""> 위의 그림을 보면 알겠지만, 모든 수명 주기 콜백 메소드를 재정의하여 구현하려면, 항상 슈퍼클래스의 구현을 호출한 다음에 다른 작업을 해야한다.

            <br><br>먼저 수명 주기 콜벡 메소드들에 대해서 알아보자.
            <ol>
              <li>onCreate()</li>
              액티비티가 처음 생성되었을 때 호출된다. <span style="color: red;">onCreate()에서 일반적인 정적 설정을 모두 수행한다.(뷰의 생성, 데이터 바인딩 등)</span> 또한 onCreate()에는 액티비티의 이전 상태가 캡처된 경우 해당 상태를 포함한 번들 객체가 전달된다.(이 점에 대해서는 따로 공부하겠다.)
              <li>onRestart()</li>
              액티비티가 중단되었다가 다시 시작되기 직전에 호출된다. 이 뒤에는 항상 onStart()가 호출된다.
              <li>onStart()</li>
              액티비티가 사용자에게 표시되기 직전에 호출된다. 즉, 실행중 상태가 되기 전에 호출 되는 것이다. onStart()가 호출된 후 액티비티의 상태 변경에 따라 onResume()과 onStop()이 호출 된다.
              <li>onResume()</li>
              액티비티가 시작되고 사용자와 상호작용하기 직전에 호출된다. onResume()이 호출된 후에 액티비티는 액티비티 스택의 맨 위에 올라가게 되며, 사용자의 포커스를 받는다.
              <li>onPause()</li>
              다른 액티비티가 시작(재개)되기 직전에 호출된다. onPause()에서는 일반적으로 데이터를 유지하기 위해 저장되지 않은 변경 사항들을 커밋하는데 사용한다. 또는 애니메이션을 비롯하여 CPU를 소모하는 기타 작업을 중단하는 등의 용도로 사용한다. <span style="color: red;">onPause()가 끝난 다음에 다음 액티비티가 시작되기 때문에 무슨일을 하든 빨리 끝내야한다.</span>
              <br>(onPause()호출 된 후) 액티비티가 다시 포커스를 받을 때는 onResume()이 다시 호출되고 액티비티가 화면에서 보이지 않게 되면 onStop()이 호출된다.
              <li>onStop()</li>
              액티비티가 사용자에게 보이지 않게 되면 호출된다. 여기서 주의할 점은 onStop()이 호출되는 것이 액티비티가 소멸(메모리에서 사라짐)되거나 정지상태(메모리에 존재함)일 때 호출된다는 것이다.
<br>데이터베이스에 데이터를 저장하는 것과 같은 무거운 작업은 onStop()에서 실행하여야 한다.
              <br>onStop()이 호출된 후 액티비티가 다시 사용자와 상호작용하면 onRestart()가 호출되고, 액티비티가 완전히 사라지면 onDestroy()가 호출된다.
              <li>onDestroy()</li>
              액티비티가 소멸되기 전에 호출된다. 액티비티의 수명 중 가장 마지막에 호출되는 메소드이다. 액티비티가 소멸되는 경우는 두 가지가 있다.
              <ol>
                <li>액티비티에서 finish() 메소드를 호출한 경우 - 액티비티가 완료되는 중</li>
                <li>시스템이 메모리 공간을 절약하기 위해 Activity 객체를 소멸시키는 경우</li>
              </ol>
              이 두가지의 경우는 액티비티 안에서 isFinishing() 이라는 메소드를 통해서 구분할 수 있다고 한다.
              <br>대부분의 앱에서는 onDestroy()는 구현할 필요가 없다고 한다. onPause()와 onStop() 중에 대부분의 정리 작업을 수행하기 때문이다.
            </ol>

            <img src="image/activity_lifecycle/activity_lifecycle_02.PNG" alt="">

            <br> 위의 액티비티의 수명 주기 콜백 메소드들 중에 onPause(), onStop(), onDestroy()가 호출된 다음에는 시스템이 메모리의 여유 공간에 따라서 액티비티를 소멸시킬 수가 있다. 하지만 다른 메소드가 호출된 다음에는 시스템이 강제로 액티비티를 소멸시킬 수가 없다.(엄밀히 말해서는 어떤 상태에 있더라도 시스템은 액티비티를 중단 할 수 있긴하다. 하지만 그러한 상황은 아주 극단적인 상황에서만 발생한다.)
            <br>이 말을 좀 더 쉽게 말하자면, '실행 중' 상태에서는 시스템이 강제로 액티비티를 소멸시킬 수 없다는 뜻을 의미하며, '일시 정지', '정지' 상태에서는 시스템이 언제든지 Activityn 객체를 메모리 상에서 소멸시킬 수 있다는 말이다.
            <br>하지만 시스템이 비상시에는 onStop()과 onDestroy() 메소드는 호출 하지 않고 메모리에서 소멸시킬 수도 있다. 바꿔 말하자면, 시스템이 액티비티를 소멸시키기 전에는 onPause() 메소드는 무조건 한번은 호출된다는 뜻이다.
            <br><br>따라서 중요한 영구적 데이터(사용자 편집 등)을 보관하기 위해서는 onPause() 메소드 안에서 구현해야한다. 하지만 여기서 유의해야할 점은 위에서처럼 onPause() 다음에 다른 액티비티의 일생이 시작되므로, onPause()에서 너무 많은 작업(너무 오래걸리는 작업)을 처리하면 사용자 환경이 느려질 수 있다는 것을 유의 해야한다.
            <br><br>이제 위에서 언급했던 구글이 나눈 액티비티의 수명에 대해서 알아보자.
            <ul>
              <li>전체 수명 - onCreate() 호출과 onDestroy() 호출 사이를 말한다. 즉, 메모리에 올라갔다가 내려올 때까지를 말한다.</li>
              onCreate()에서 리소스의 설정 등을 수행하면 onDestroy()에서는 해제해 주어야한다.(네트워크의 연결을 위해 스레드를 사용할 경우 onCreate()에서 스레드를 생성하고 onDestroy()에서 그 스레드를 중단해야 한다.)
              <li>가시적 수명 - onStart() 호출과 onStop() 호출 사이를 말한다. 이 기간 중에는 사용자가 액티비티를 화면에서 볼 수 있으며 이와 상호작용 할 수 있다.</li>
              <li>전경 수명 - onResume() 호출과 onPause() 호출 사이를 말한다. 액티비티가 화면에서 다른 모든 액티비티 앞에 표시되며 사용자의 입력도 여기에 집중된다.</li>
              액티비티는 포그라운드에 나타났다 숨겨지는 전환을 자주 반복할 수 있다.(절전모드에 들어가거나 대화상자가 나타나면 onPause()를 호출) 이 상태 전환은 자주 될 수 있으므로 onResume()과 onPause()는 아주 가벼워야 한다.
            </ul>

            <img src="image/activity_lifecycle/activity_lifecycle_03.PNG" alt=""> 위의 그림은 액티비티 수명 주기를 계단식 피라미드로 간략하게 표현한 것이다. 여기 그림에는 Created와 Started 상태가 있지만 액티비가 이 상태에 머무는 것은 굉장히 일시적이라고 하며 그 외의 상태에는 오랫동안 머문다고 한다.

            <br><br>액티비티 A가 Resumed 상태일 때 액티비티 A가 액티비티 B를 시작했을 때의 콜백 메소드들의 호출 순서를 알아보자.
            <ol>
              <li>액티비티 A의 onPause() 메소드가 실행된다.</li>
              <li>액티비티 B의 onCreate(), onStart(), onResume() 메소드가 순서대로 실행된다.</li>
              <li>액티비티 A가 더이성 화면에 보이지 않는 경우 액티비티 A의 onStop()이 실행된다.</li>
            </ol>
            위와 같은 순서로 콜백 메소드들이 실행된다. 그렇기 때문에 액티비티 B에서 액티비티 A의 무엇인가가 필요하다면 onStop()이 아닌 onPause()에서 그에 대한 처리를 해주어야한다.(액티비티 실행시 인텐트로 데이터를 전달하는 것을 말하는 것이 아니다.)
          </p>
        </article>
      </li>

      <li>
        <article>
          <h2>액티비티 상태 저장</h2>
          <p>
            위에서 액티비티가 일지 정지 상태나 정지 상태여도 메모리 상에서 Activity의 객체는 남아서 상태가 저장된다고 하였다. 하지만 시스템이 메모리에서 소멸시키고 액티비티를 다시 실행시키면 액티비티의 상태를 온전히 유지하지 못한채로 액티비티가 다시 실행된다.
            <br>안드로이드에서는 액티비티의 상태에 관한 정보를 저장할 수 있는 추가 콜백 메소드를 제공한다. 바로 onSaveInstanceState()와 onRestoreInstanceState() 메소드이다. onSaveInstanceState()와 onRestoreInstanceState()를 재정의하여 액티비티의 상태 저장과 복구를 할 수 있다.(이 두 메소드 또한 재정의 할 때 슈퍼클래스의 것을 먼저 호출해주어야한다.)
            <br><br>액티비티 상태 정보를 저장할 때는 onSaveInstanceState() 메소드를 사용한다. 시스템이 onSaveInstanceState() 메소드를 호출하여 액티비티에 관한 상태정보를 이름-값 쌍으로 저장할 수 있는 Bundle을 만들고 저장한다. onSaveInstanceState가 호출된 다음에는 액티비티는 소멸되기 쉬운 상태가 된다.(정확히 어떠한 형태(파일이라던지)로 저장하는 지는 모르겠다.)
            <br>액티비티(메모리에서 소멸된 상황)가 다시 실행될 때 Bundle을 onCreate()나 onRestoreInstanceState()로 전달한다. 이 두 메소드 중 하나를 사용하여 Bundle에 저장된 상태를 추출하고 액티비티의 상태를 복원할 수 있다. 복구할 정보가 없는 경우에는 Bundle에 null이 들어가서 전달된다.(액티비티가 처음 생성되는 경우)
            <img src="image/activity_lifecycle/activity_lifecycle_05.PNG" alt="">
            <br>물론 모든 onPause(), onStop(), onDestroy()가 호출되기 전에 무조건 onSaveInstanceState()가 호출되는 것은 아니다.(대표적으로 사용자가 명식적으로 Back 버튼을 눌러서 액티비티를 종료할 때는 호출되지 않는다.) 시스템이 호출하는 경우는 onStop() 전에 호출하는 것이 일반적이며 onPause() 전에 호출할 가능성도 높다.

            <br><br>또한 onSaveInstanceState()를 구현하지 않더라도 안드로이드 프레임워크에 의해 기본적으로 제공되는 상태 저장도 있다. 위젯들은 거의 대부분 이 메소드를 필요에 따라 구현하므로, UI에 눈에 보이는 변경이 있으면 모두 자동으로 저장되며 액티비티를 다시 생성하면 복구됩니다. (EditText에 사용자가 입력한 모든 텍스트, CheckBox에 체크된 항목) 단, 각 위젯에 고유 ID가 설정되어 있어야합니다.

            <br><br>액티비티의 상태를 저장하고 복구하는 것을 구현하고 제대로 구현되었는지 테스트해보는 가장 좋은 방법은 화면을 가로로 바꿔보는 것이다. 화면이 세로에서 가로로, 가로에서 세로로 바뀔 때 시스템은 액티비티를 완전히 소멸(onDestroy()) 시켰다가 다시 생성(onCreate())합니다. 때문에 액티비티가 제대로 복구가 되었느지 확인해볼 수 있습니다.
          </p>
        </article>
      </li>

    </ul>

  </section>

  <br>
  <div style="border-bottom: 2px solid black;"></div>
  <footer>
    최초 작성일 : 2016-11-23 (수요일)
    <br>참고 자료
    <ul>
      <li> <a href="https://developer.android.com/guide/components/activities.html" target="_blank">액티비티 - 안드로이드 개발자 사이트(API 가이드 - 액티비티)</a> </li>
      <li><a href="https://developer.android.com/training/basics/activity-lifecycle/starting.html" target="_blank">액티비티 시작하기 - 안드로이드 개발자 사이트(교육 - 액티비티 수명 주기 관리하기)</a></li>
    </ul>
  </footer>
</body>

</html>
